Title,Text,AnswerAccepted
"Calculate Picture ID for Gallery With Ads","I have a picture gallery where after every three pictures, an ad is displayed (gotta pay those bills ðŸ˜€).

So in an example scenario, my gallery would have 11 slides, of which there are 9 pictures and 2 ads, like this:

[![gallery][1]][1]

In the top row of this drawing are the zero-bases indexes of the slides, which I have in an array.

What I need to come up with now is a formula to calculate the index of the picture corresponding to a given slide ID (the numbers in the bottom row).

So for `slideIndex === 2`, I need `picIndex === 2`, for `slideIndex === 5`, I need `picIndex === 4` and for `slideIndex === 8`, the result would be `picIndex === 6`.

For a slide that contains an ad, I would like to have the index of the last pic, so for `slideIndex === 3` â†’ `picIndex === 2`.

I do have a working solution already, where I just use a `for` loop, but this seems really lame and cumbersome:

<!-- begin snippet: js hide: false console: true babel: false -->

<!-- language: lang-js -->

    const adInterval = 3; // show an ad every 3 pics

    function calculatePicIndex(slideIndex) {
        let picCount = 0;
        let picIndex = -1;
        for (let i = 0; i <= slideIndex; i++) {
            if (++picCount > adInterval) {
                picCount = 0;
            } else {
                picIndex++;
            }
        }
        return picIndex;
    }

    for (let i = 0; i < 11; i++) {
        console.log(`slide index: ${i} â€“ pic index: ${calculatePicIndex(i)}`);
    }

<!-- end snippet -->

I'm sure there is a much more elegant solution with a simple math formula, so basically, it's more a math question than a JavaScript question:

**How can I refactor the above code to avoid the loop and calculate the number through a math formula?**

I have tried something like this:

    const picIndex = Math.floor(slideIndex / adInterval);

But that gives me incorrect values which are more and more off as slide index increases.

  [1]: https://i.stack.imgur.com/IR4Nm.png","

<!-- begin snippet: js hide: false console: true babel: false -->

<!-- language: lang-js -->

    slideIndex = 8;
    adInterval = 3;
    var picindex = slideIndex - slideIndex%adInterval || slideIndex
    console.log(picindex)


<!-- end snippet -->

"
"Node js, refactoring long node js async function","I'm converting SQL Procedure to node js function.

My converting function is too long, so readability is bad.

I want to split small function, but don't know how I can refactoring it.
I use async.wait because several SQL statement should be run serial.



    exports.cancelDansok =  function cancelDansok(dansokSeqNo, callback) {
           var tasks = [
             function (callback) {
               models.DansokHist.max('SerialNo', {
                 where: { DansokSeqNo: dansokSeqNo}
               })
               .then(max => {
                 if (!max) {
                   callback(null, 1);
                 } else {
                   callback(null, max+1);
                 }
               })
               .error(err => {
                 log.info(err);
                 return callback({status:400, message:'select dansokhisttbl failed.'});
               });          
             },
             function (serialNo, callback) {
                ....
               })
               .then(() => {
                 ....
               })
               .then( feeVBankList => {
                 callback(null);
               })
               .error(err => {
                 return callback({status:400, message:'update dansokfeetbl failed.'});
               });          
             },
             function (callback) {        
               ....
             },
             function (callback) {        
               ....
             },
             function (callback) {        
               ....
             },
             function (callback) {        
               ....
             }
           ];
        
           async.waterfall(tasks, function(err, success) {
             if (err) {
               return callback(err);
             } else {
               return callback(success);
             }
           });
         }

What would be the best practice in my case?
","I would create a named function for each `function (callback) {` and then replace them in the tasks array by the newly created function name.

Plus I'll wrap the callback functions into `Promises` and use `Promise.all`.

*Example :*

      /**
       * I love cats!
       */
      function loveCats() {
        return new Promise((resolve, reject) => {
          models.DansokHist.max('SerialNo', {
            where: { DansokSeqNo: dansokSeqNo }
          })
           .then(max => resolve(!max ? 1 : max + 1))
           .error(err => reject({
              status: 400,
              message: 'select dansokhisttbl failed.',
            }));
        });
      }

      /**
       * I love dogs!
       */
      function loveDogs() {
        // ...
      }

      Promise.all([
        loveCats,
        loveDogs,
        ...
      ])
       .then((allRets) => {
         // Handle the rets
       })
       .catch((err) => {
         // Handle the errors
       });


----------

Even better you can use new supported features `async/await`.

      /**
       * I love cats!
       */
      function loveCats() {
        return new Promise((resolve, reject) => {
          models.DansokHist.max('SerialNo', {
            where: { DansokSeqNo: dansokSeqNo }
          })
           .then(max => resolve(!max ? 1 : max + 1))
           .error(err => reject({
              status: 400,
              message: 'select dansokhisttbl failed.',
            }));
        });
      }

      /**
       * I love dogs!
       */
      function loveDogs() {
        // ...
      }

      try {
        const allRets = await Promise.all([
          loveCats,
          loveDogs,
          ...
        ]);

        // Handle the rets
      } catch (err) {
        // Handle the errors
      }"
"Elixir rename imported function to alias","Let's say I am testing a function belonging to Utils module like this

    defmodule Test do
      alias Module.Utils
    
      test ""test 1"" do
        Utils.some_function?(...)
      end
    
      test ""test 2"" do
        Utils.some_function?(...)
      end
    end

Can I refactor or simplify that function into something like:

    import Utils.some_function as test_func()

So I dont have to write module name and simplify function name
","You cannot rename a function while importing it.

You can use `defdelegate` to create a local function that calls another module's function like this:

    defmodule A do
      def just_add_these_two_numbers(a, b), do: a + b
    end
    
    defmodule B do
      defdelegate add(a, b), to: A, as: :just_add_these_two_numbers
      # `add/2` is now the same as `A.just_add_these_two_numbers/2`.
    
      def test do
        IO.inspect add(1, 2) == 3
      end
    end
    
    B.test #=> true

Although you might as well just do this instead (it's even shorter):

    def add(a, b), do: A.just_add_these_two_numbers(a, b)"
"Why jQuery's Promise.reject does not working?","I have existing jQuery-code on classics callbacks: [Github Gist 1][1]

which is executes with logs: 
    
logs case 1:

    [INFO] /api/my/action1: got rejecting signal, do not continue 
    
logs 2nd case:

    [INFO] /api/my/action1: no rejecting signal, continue
    [INFO] /api/my/action2: no rejecting signal, continue
    [INFO] /api/my/action3: hurrah!! we got message:  Third action executed!
    
logs 3d case:

    [INFO] /api/my/action1: no rejecting signal, continue
    [ERROR] Got error with message: Unexpected error
    
I want to refactor this code to to promises:

    function ajxGet(url){
      return $.ajax({
        url,
        dataType: 'JSON'
      })
    }
    
    export function makeThreeAsyncQueries(){
      ajxGet('/api/my/action1')
        .then(response1 => {
          if(response1.do_reject_other_actions){
            console.log('[INFO] /api/my/action1: got rejecting signal, do not continue');
            return Promise.reject({mute: true});
          }else{
            console.log('[INFO] /api/my/action1: no rejecting signal, continue');
            return ajxGet('/api/my/action2');
          }
        })
        .then(response2 => {
          if(response2.do_reject_other_actions){
            console.log('[INFO] /api/my/action2: got rejecting signal, do not continue');
            return Promise.reject({mute: true});
          }else{
            console.log('[INFO] /api/my/action2: no rejecting signal, continue');
            return ajxGet('/api/my/action3');
          }
        })
        .then(response3 => {
          console.log('[INFO] /api/my/action3: hurrah!! we got message: ', response3.message);
        })
        .fail((err) => {
          if(err && err.mute){
            console.log('[INFO] normal chain break.');
            return
          }
          console.info('[ERROR] Got error with message:', err.responseJSON.message);
        });
    }
 
The problem is that 'Promise.reject({mute: true});' does not working, and I have these logs: 

    [INFO] /api/my/action1: got rejecting signal, do not continue           <<-- SHOULD STOP HERE
    my.js?be90:79 [INFO] /api/my/action2: no rejecting signal, continue
    my.js?be90:69 Uncaught (in promise) Object {mute: true}
    (anonymous) @ my.js?be90:69
    (anonymous) @ jquery-1.12.4.min.self-693ce44â€¦.js?body=1:3
    i @ jquery-1.12.4.min.self-693ce44â€¦.js?body=1:3
    fireWith @ jquery-1.12.4.min.self-693ce44â€¦.js?body=1:3
    y @ jquery-1.12.4.min.self-693ce44â€¦.js?body=1:5
    c @ jquery-1.12.4.min.self-693ce44â€¦.js?body=1:5
    my.js?be90:83 [INFO] /api/my/action3: hurrah!! we got message:  Third action executed!
    
Rails-API code: [Github Gist 2][2]

    
    
    
  [1]: https://gist.github.com/NikolayRadionov/8c016405a2a6a40fb31b64eac073c0c4
  [2]: https://gist.github.com/NikolayRadionov/69072abc90ff5fa6a5d6de4a65f0466b","In your example, you are using [Promise][1] from [ECMAScript 2015 specification][3] instead of jQuery's [Deferred][2] promise-like object.

So instead of this line:

    return Promise.reject({mute: true});
    
Use this:

    return $.Deferred().reject({ mute: true }) 
    
Full example of code:

    function ajxGet(url){
      return $.ajax({
        url,
        dataType: 'JSON'
      })
    }
    
    export function makeThreeAsyncQueries(){
      ajxGet('/api/my/action1')
        .then(response1 => {
          if(response1.do_reject_other_actions){
            console.log('[INFO] /api/my/action1: got rejecting signal, do not continue');
            return $.Deferred().reject({ mute: true })
          }else{
            console.log('[INFO] /api/my/action1: no rejecting signal, continue');
            return ajxGet('/api/my/action2');
          }
        })
        .then(response2 => {
          if(response2.do_reject_other_actions){
            console.log('[INFO] /api/my/action2: got rejecting signal, do not continue');
            return $.Deferred().reject({ mute: true })
          }else{
            console.log('[INFO] /api/my/action2: no rejecting signal, continue');
            return ajxGet('/api/my/action3');
          }
        })
        .then(response3 => {
          console.log('[INFO] /api/my/action3: hurrah!! we got message: ', response3.message);
        })
        // as argument here we will get jquery's xhr object on AJAX-error, or will get payload sent by $.deferred().reject
        .fail((xhr) => {
          if(xhr && xhr.mute){
            console.log('[INFO] normal chain break.');
            return
          }
          console.info('[ERROR] Got error with message:', xhr.responseJSON.message);
        });
    }

So when backend will return `do_reject_other_actions === true` chain will break and you will get this correct logs:

<!-- language: lang-none -->

    [INFO] /api/my/action1: got rejecting signal, do not continue
    [INFO] normal chain break.
    
    or
    
    [INFO] /api/my/action1: no rejecting signal, continue
    [INFO] /api/my/action2: got rejecting signal, do not continue
    [INFO] normal chain break.
    
    or

    [INFO] /api/my/action1: no rejecting signal, continue
    [INFO] /api/my/action2: no rejecting signal, continue
    [INFO] /api/my/action3: hurrah!! we got message:  Third action executed!
    
    or
    
    [INFO] /api/my/action1: no rejecting signal, continue
    [ERROR] Got error with message: Unexpected error 
    
    
    
# SOLUTION 2
    
If you want to use [ECMAScript2015 Promise][1], you can wrap jQuery's `ajax` into [Promise][1]:

    function ajxGet(url){
      return new Promise((resolve, reject) => {
        $.ajax({
          url,
          dataType: 'JSON',
          success: response => resolve(response),
          error: (xhr) => { reject(xhr) },
        })
      });
    }
    
    export function makeThreeAsyncQueries(){
      ajxGet('/api/my/action1')
        .then(response1 => {
          if(response1.do_reject_other_actions){
            console.log('[INFO] /api/my/action1: got rejecting signal, do not continue');
            return Promise.reject({mute: true});
          }else{
            console.log('[INFO] /api/my/action1: no rejecting signal, continue');
            return ajxGet('/api/my/action2');
          }
        })
        .then(response2 => {
          if(response2.do_reject_other_actions){
            console.log('[INFO] /api/my/action2: got rejecting signal, do not continue');
            return Promise.reject({mute: true});
          }else{
            console.log('[INFO] /api/my/action2: no rejecting signal, continue');
            return ajxGet('/api/my/action3');
          }
        })
        .then(response3 => {
          console.log('[INFO] /api/my/action3: hurrah!! we got message: ', response3.message);
        })
        .catch((xhr) => {
          if(xhr && xhr.mute){
            console.log('[INFO] normal chain break.');
            return
          }
          console.info('[ERROR] Got error with message:', xhr.responseJSON.message);
        });
    }
    
    
Note that instead of `fail(...)` you will need to use `catch(...)` at the end of chain, because [`fail`][4] is jQuery Deferred's method. 






  [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise
  [2]: http://api.jquery.com/category/deferred-object/
  [3]: http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects
  [4]: http://api.jquery.com/deferred.fail/"
"Induction hypothesis for free variables of closed term in the simply typed lambda calculus","I am trying to formalize the simply typed lambda calculus in Coq and have a problem stating the lemma that the set of free variables of a well-typed expression in an empty context is empty.

Here is the relevant part of may formalisation.

    Require Import Coq.Arith.Arith.
    Require Import Coq.MSets.MSets.
    Require Import Coq.FSets.FMaps.
    
    Inductive type : Set :=
    | tunit : type
    | tfun : type -> type -> type.
    
    Module Var := Nat.
    Definition var : Set := Var.t.
    Module VarSet := MSetAVL.Make Var.
    Module VarSetFacts := MSetFacts.Facts VarSet.
    Module VarSetProps := MSetProperties.Properties VarSet.
    Module Context := FMapWeakList.Make Var.
    Module ContextFacts := FMapFacts.Facts Context.
    Module ContextProps := FMapFacts.Properties Context.
    Definition context := Context.t type.
    Definition context_empty : context := Context.empty type.
    
    Inductive expr : Set :=
    | eunit : expr
    | evar : var -> expr
    | eabs : var -> type -> expr -> expr
    | eapp : expr -> expr -> expr.
    
    Fixpoint free_vars (e : expr) : VarSet.t :=
      match e with
      | eunit => VarSet.empty
      | evar y => VarSet.singleton y
      | eabs y _ e => VarSet.remove y (free_vars e)
      | eapp e1 e2 => VarSet.union (free_vars e1) (free_vars e2)
      end.
    
    Inductive has_type : context -> expr -> type -> Prop :=
    | has_type_unit : forall c,
        has_type c eunit tunit
    
    | has_type_var : forall c x t,
        Context.find x c = Some t ->
        has_type c (evar x) t
    
    | has_type_abs : forall c x t1 t2 e,
        has_type (Context.add x t1 c) e t2 ->
        has_type c (eabs x t1 e) (tfun t1 t2)
    
    | has_type_app : forall c e1 e2 t1 t2,
        has_type c e1 (tfun t1 t2) ->
        has_type c e2 t1 ->
        has_type c (eapp e1 e2) t2.
        
    Check has_type_ind.
    
    Lemma has_type_empty_context_free_vars : forall e t,
      has_type context_empty e t ->
      VarSet.Empty (free_vars e).
    Proof.
      intros e t H.
      remember context_empty as c.
      induction H; subst.
      - apply VarSet.empty_spec.
      - rewrite ContextFacts.empty_o in H.
        congruence.
      - simpl.
        admit. (* Wrong induction hypothesis *)
      - simpl.
        rewrite VarSetProps.empty_union_1; auto.
    Admitted.

The problem seems to be that my induction hypothesis is wrong. It merely says

    Context.add x t1 context_empty = context_empty ->
      VarSet.Empty (free_vars e)

which is trivially true, since the hypothesis is false. I tried an induction over the expression and to reformulate the theorem to get the right induction hypothesis, but could not figure it out.

What is the correct way to define and prove this property?","You were right to perform induction on the hypothesis of statement ""has_type ..."", but you probably need to load the induction.  In other words, you need to prove a stronger statement, make the environment a variable, and express that the set of free variables in <code>e</code> must be inside the variables that have a type in your context."
"Cannot create FactoryGirl's factory for model","I have this situation with legacy project. Suppose I have rails 'entity'-model with string 'name'-field. In that model there is **MAIN_ENTITY** constant:

`class Entity < ActiveRecord::Base  
  MAIN_ENTITY_ID = 1
  MAIN_ENTITY = Entity.find(MAIN_ENTITY_ID)
end`
    
Now I want to cover Entity-model with rspec tests, but first I need factory. I created this factory: 

`FactoryGirl.define do
  factory :entity do
    name { FFaker::Company.name }
  end
end`

And when I running create(:entity) inside rspec test, I am getting this error: 

    Failure/Error: MAIN_ENTITY = Entity.find(MAIN_ENTITY_ID)
    
    ActiveRecord::RecordNotFound:
      Couldn't find Entity with 'id'=1

      
      
How to fix that without refactoring code and keeping MAIN_ENTITY constant?
","### Solution without refactoring (hack)

Ruby constants initializing before you access the static content of class. So, when you calling `Entity` class (manually or by using FactoryGirl), in background there is SQL query, which is trying to find record with `id == 1`. 

In case of production, this code is working, but when you writing tests, your database usually is cleaning up after each test case run (rspec's `it`). So solution would be to create 'main entity' before each test case run in empty database:

    # Your DatabaseCleaner initializer file
    RSpec.configure do |config|
      # ...
      config.around(:each) do |example|
        DatabaseCleaner.cleaning do
          FactoryGirl.create_main_entity
          example.run
        end
      end
    end

In `create_main_entity` method we have limitation here: we cannot use `Entity.create` or `Entity.new` methods, so we should use more low level solution: we need to make `INSERT` query directly into database. I would rewrite your `entities.rb`-factory like this:

    FactoryGirl.define do
      factory :entity do
        name { FFaker::Company.name }
      end
    end
    
    
    module FactoryGirl
      def self.create_main_entity
        connection = ActiveRecord::Base.connection
    
        values = {
          id: 1,
          name: 'MAIN ENTITY',
          created_at: Time.now.to_s(:db),
          updated_at: Time.now.to_s(:db)
        }
    
        sql = <<-SQL
          INSERT INTO entities (#{values.keys.map {|k| k.to_s}.join(', ')})
          VALUES(#{values.values.map{""'%s'""}.join(', ')})
        SQL
        
        connection.insert(sql % values.values)
      end
    end
    
### Better solution with refactoring

My code above is temporary solution. I would recommend you to refactor your `Entity` model. Instead of initializing constant by finding record, you can use static method:

    class Entity < ActiveRecord::Base
      MAIN_ENTITY_ID = 1
      
      def self.main_entity
        @@main_entity ||= Entity.find(MAIN_ENTITY_ID)
      end
    end

I used memorization here `@@main_entity ||= ...` to avoid executing same SELECT-query on each `Entity.main_entity` call.

"
"Ionic3, AngularFire - Property 'remove' does not exist on type 'Observable<any[]>'","I have been following an outdated tutorial ([this playlist in particular](https://www.youtube.com/watch?v=UHTBnTg4rno&list=PLtKjv92L0ihAJ90_NbqCINRu4uKy3RJJU&index=13)) and I got lost switching between AngularFire 4.0 and AngularFire 5.0.
It's a simple CRUD application which implements Firebase.
The code is uncouth, but I am able to view and post to the database.

<!-- What are you trying to accomplish? (Please include sample data.) -->
I'm trying to delete an item from a node using the key in firebase, but I'm getting the error 

`Property 'remove' does not exist on type 'Observable<any[]>'.`

Here is my `.ts` file:

    import { Component } from '@angular/core';
    import { IonicPage, NavController, NavParams, ActionSheetController } from 'ionic-angular';
    import { AngularFireList, AngularFireDatabase } from 'angularfire2/database';
    import { Matatu } from '../../models/matatu/matatu.interface';
    import { Observable } from 'rxjs/Observable';
    
    @IonicPage()
    @Component({
      selector: 'page-owner-dash',
      templateUrl: 'owner-dash.html',
    })

    export class OwnerDashPage {
    
      matatuListRef$: Observable<any[]>;
    
      constructor(public navCtrl: NavController, public navParams: NavParams, private database: AngularFireDatabase, public actionShtCrtl: ActionSheetController) {
        this.matatuListRef$ = this.database.list('matatu-list').valueChanges();
    
      }
    
      ionViewDidLoad() {
        //
      }
    
      selectMatatu(matatu: Matatu){
        this.actionShtCrtl.create({
          title: `${matatu.matNumberPlate}`,
          buttons: [
            {
              text: 'Edit',
              handler: () => {
                //
              }          
            },
            {
              text: 'Delete',
              role: 'destructive',
              handler: () => {
                this.matatuListRef$.remove(matatu.$key);
              }
            },
            {
              text: 'Cancel',
              role: 'cancel',
              handler: () => {
                //
              }
            }
          ]
        }).present();
      }
      
    
    }



And here the `.html` code that displays the records.

    ...
    <ion-list>
        <button ion-item *ngFor=""let ma3 of matatuListRef$ | async"" (click)=""selectMatatu(ma3)"">
          <h2 style=""font-weight: bold;"">{{ma3.matNumberPlate}}</h2>
          <h3>Driver: {{ma3.matDriver}}</h3>
          <h3>Status: {{ma3.matStatus}}</h3>
        </button>
      </ion-list>
    ...

<!-- Paste the part of the code that shows the problem. (Please indent 4 spaces.) -->
I know `FirebaseListObservable` was refactored to `AngularFireList`, but I assigned my variable to the type `Observable` instead.

`matatuListRef$: Observable<any[]>;`

Bottom line, I get the error `TypeError: _this.matatuListRef$.remove is not a function` on the browser's console when I try to delete the record.


How can I resolve this? 
All suggestions and approaches are highly welcomed,but I would really appreciate it if the solutions focused on using `AngularFireList`.


","`remove()` function is present on the list reference retrieved from Firebase and _not the Observable_ from `valueChanges()`.

You need to set 

    this.matatuListRef$ = this.database.list('matatu-list');
    this.matatuListAsync = this.matatuListRef$.valueChanges();

instead of 

    this.matatuListRef$ = this.database.list('matatu-list').valueChanges();

You can  use `this.matatuListAsync` in the `*ngFor` in the HTML"
"Add data to DataTable-Bootstrap","I need to know how to add data from  database to DataTable-Bootstrap

This is my table:

    <div class=""container"">
    <button id=""addRow"">Add new row</button>
     <table id=""example"" class=""display"" cellspacing=""0"" width=""100%"">
        <thead>
            <tr>
                <th>Column 1</th>
                <th>Column 2</th>
                <th>Column 3</th>

            </tr>
        </thead> 
    </table>
    </div>

I have a script that add from my database the data automatically to DataTable-Bootstrap

    <script>
    var tblusuario = document.getElementById('example');
    var databaseRef = firebase.database().ref('Usuarios/');
    //var databaseRef = FirebaseFirestore.database().ref('/users');
    var rowindex = 1;

    databaseRef.once('value', function(snapshot) {
        snapshot.forEach(function(childSnapshot) {

            var childKey = childSnapshot.key;
            var childData = childSnapshot.val();

            var row = tblusuario.insertRow(rowindex);
            var cellIndice= row.insertCell(0);
            var cellId = row.insertCell(1);
            var cellNombre = row.insertCell(2);


            cellIndice.innerHTML=rowindex;
            cellId.appendChild(document.createTextNode(childKey));
            cellNombre.appendChild(document.createTextNode(childData.usuario));

                rowindex = rowindex + 1;


        });
    });
</script>

**BUT THE TABLE DOES NOT RECOGNIZE IT**, I can't use the use the functionalities of DataTable

[See the table][1]

After this, I have been studying for 3 days to change the code to put it in the table

I have took this reference(it's okey)

 
       <button id=""addRow"">Add new row</button>
       <script>
       
       $(document).ready(function() {
       var t = $('#example').DataTable();
       var counter = 1;
 
       $('#addRow').on( 'click', function () {
        t.row.add( [
            counter +'.1',
            counter +'.2',
            counter +'.3',

        ] ).draw( false );
 
           counter++;
       } );
 
       // Automatically add a first row of data
       $('#addRow').click();
        } );

</script>


So far, I want to refactor my code in order funtion to dataTable

I have this, but it doesnÂ´t work :(

   

    <script>
  

    $(document).ready(function() {
    var t = $('#example').DataTable();
    var counter = 1;
    var databaseRef = firebase.database().ref('Usuarios/');
    var rowindex = 1;
     databaseRef.once('value', function(snapshot) {
    snapshot.forEach(function(childSnapshot) {
    var childKey = childSnapshot.key;
    var childData = childSnapshot.val();

    var addhere = childKey;
    var b = childData.usuario;

                });
        });
 
      $('#addRow').on( 'click', function () {
  
        t.row.add( [
            addhere,//PROBLEM
            'hola',
            '.3',
        ] ).draw( false );
 
        
       } );
 
      // Automatically add a first row of data
      $('#addRow').click();
     } );

</script>


Someone can help me with the code?
Thanks


  [1]: https://i.stack.imgur.com/Xy4o3.png","By seeing your code it seems you are using [Firebase JavaScript client SDK][1]. So what you can do is retrieve the data from firebase and then inject it to DataTables.

    databaseRef.once('value', function(snapshot) {
      $('#example').DataTable({
        data : snapshot.val()  
      });
    });
You need to keep one thing in mind that data that is being send by the firebase should be in context with the [DataTables Data source types
][2], otherwise you have to use [columns.data][3] or [columns.render][4] to modify the received data.


  [1]: https://firebase.google.com/docs/web/setup
  [2]: https://datatables.net/manual/data/#Data-source-types
  [3]: https://datatables.net/reference/option/columns.data
  [4]: https://datatables.net/reference/option/columns.render"
"Redux Form - initialValues not updating when using compose","reference: https://redux-form.com/6.7.0/examples/initializefromstate/

I am trying to implement a profile form that updates with initial data that is fetched from an api endpoint.

I've been able to get the example to work when referencing the redux-form example above. However when I refactor it to use compose 'initialValues' does not get inserted into the fields. 

This code does not work, initialValues contains data but does not insert into form fields.

    export default compose(
        reduxForm({
            form: 'initializeFromState',
            enableReinitialize : true
        }),
        connect(state => ({
            initialValues: state.profile, // pull initial values from account reducer
        }), actions)
    )(EditProfile);

However this code works which is just slightly modified from reference example. 'initialValues' also contains data.

    EditProfile = reduxForm({
        form: 'initializeFromState', 
        enableReinitialize: true
    })(EditProfile);
    
    EditProfile = connect(
        state => ({
            initialValues: state.profile, 
        }),
        actions, 
    )(EditProfile);
    
    export default EditProfile;

It's looks similar to me but maybe I can't use compose like this? ","You're passing the arguments to `compose` in the wrong order. Composed functions execute from the end toward the beginning. So you'll need to reverse the order to have the equivalent of what you've got in the second example:

    export default compose(
        connect(state => ({
            initialValues: state.profile, // pull initial values from account reducer
        }), actions),
        reduxForm({
            form: 'initializeFromState',
            enableReinitialize : true
        })
    )(EditProfile);"
"Swagger2 too many the same annotations","I integrate swagger2 to springboot project, because all of my endpoints authorization is by OAuth2, so I need to add Authorization header to every method, like the following code:

    @ApiImplicitParams({     
        @ApiImplicitParam(paramType=""header"",name=""Authorization"",dataType=""String"",required=true, value=""Bearer {access-token}"")
    })


These same annotations are too many, can I have some ways to refactor them?

","I spend couple of days to find out the solution. Here I give you the docket config for `access_token`. Configure a global parameter, can say common parameters (`access_token`) that includes every end-point. Probable docket configuration given below (later your can changed of your own for api info).

    @Bean
    public Docket api() {
        return new Docket(DocumentationType.SWAGGER_2)
                .select()
                .apis(RequestHandlerSelectors.basePackage(""com.xxx.yyy.resource""))
                .paths(PathSelectors.any())
                .build()
                .globalOperationParameters(commonParameters())
                .apiInfo(apiInfo())
				.ignoredParameterTypes(TokenInfo.class, HttpServletRequest.class, HttpServletResponse.class)
                .securityContexts(Lists.newArrayList(securityContext()))
                .securitySchemes(Lists.newArrayList(apiKey()));
	}
	
	
	private List<Parameter> commonParameters() {
        List<Parameter> parameters = new ArrayList<Parameter>();
        parameters.add(new ParameterBuilder()
                .name(""access_token"")
                .description(""token for authorization"")
                .modelRef(new ModelRef(""string""))
                .parameterType(""query"")
                .required(true)
                .build());

        return parameters;
    }
	
	private ApiInfo apiInfo() {
        ApiInfo apiInfo = new ApiInfo(
                ""My REST API"",
                ""Some custom description of API."",
                ""API TOS"",
                ""Terms of service"",
                ""myeaddress@company.com"",
                ""License of API"",
                ""API license URL"");
        return apiInfo;
    }
	
	private SecurityContext securityContext() {
        return SecurityContext.builder()
                .securityReferences(defaultAuth())
                .forPaths(PathSelectors.any())
                .build();
    }
	
	List<SecurityReference> defaultAuth() {
        AuthorizationScope authorizationScope
                = new AuthorizationScope(""global"", ""accessEverything"");
        AuthorizationScope[] authorizationScopes = new AuthorizationScope[1];
        authorizationScopes[0] = authorizationScope;
        return Lists.newArrayList(
                new SecurityReference(""AUTHORIZATION"", authorizationScopes));
    }

	private ApiKey apiKey() {
        return new ApiKey(""AUTHORIZATION"", ""access_token"", ""header"");
    }

Just paste the code and try from `swagger-ui` and let me know the status."